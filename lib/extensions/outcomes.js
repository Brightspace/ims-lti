if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
(function(_export) {
    if (typeof _export._$jscoverage === 'undefined') {
        _export._$jscoverage = _$jscoverage;
    }
})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this);
if (! _$jscoverage["outcomes.coffee"]) {
    _$jscoverage["outcomes.coffee"] = [];
    _$jscoverage["outcomes.coffee"][1] = 0;
    _$jscoverage["outcomes.coffee"][2] = 0;
    _$jscoverage["outcomes.coffee"][3] = 0;
    _$jscoverage["outcomes.coffee"][4] = 0;
    _$jscoverage["outcomes.coffee"][5] = 0;
    _$jscoverage["outcomes.coffee"][8] = 0;
    _$jscoverage["outcomes.coffee"][9] = 0;
    _$jscoverage["outcomes.coffee"][11] = 0;
    _$jscoverage["outcomes.coffee"][12] = 0;
    _$jscoverage["outcomes.coffee"][13] = 0;
    _$jscoverage["outcomes.coffee"][16] = 0;
    _$jscoverage["outcomes.coffee"][17] = 0;
    _$jscoverage["outcomes.coffee"][18] = 0;
    _$jscoverage["outcomes.coffee"][20] = 0;
    _$jscoverage["outcomes.coffee"][24] = 0;
    _$jscoverage["outcomes.coffee"][26] = 0;
    _$jscoverage["outcomes.coffee"][28] = 0;
    _$jscoverage["outcomes.coffee"][32] = 0;
    _$jscoverage["outcomes.coffee"][33] = 0;
    _$jscoverage["outcomes.coffee"][35] = 0;
    _$jscoverage["outcomes.coffee"][36] = 0;
    _$jscoverage["outcomes.coffee"][39] = 0;
    _$jscoverage["outcomes.coffee"][40] = 0;
    _$jscoverage["outcomes.coffee"][43] = 0;
    _$jscoverage["outcomes.coffee"][47] = 0;
    _$jscoverage["outcomes.coffee"][48] = 0;
    _$jscoverage["outcomes.coffee"][50] = 0;
    _$jscoverage["outcomes.coffee"][51] = 0;
    _$jscoverage["outcomes.coffee"][52] = 0;
    _$jscoverage["outcomes.coffee"][56] = 0;
    _$jscoverage["outcomes.coffee"][60] = 0;
    _$jscoverage["outcomes.coffee"][64] = 0;
    _$jscoverage["outcomes.coffee"][68] = 0;
    _$jscoverage["outcomes.coffee"][72] = 0;
    _$jscoverage["outcomes.coffee"][73] = 0;
    _$jscoverage["outcomes.coffee"][74] = 0;
    _$jscoverage["outcomes.coffee"][75] = 0;
    _$jscoverage["outcomes.coffee"][79] = 0;
    _$jscoverage["outcomes.coffee"][81] = 0;
    _$jscoverage["outcomes.coffee"][86] = 0;
    _$jscoverage["outcomes.coffee"][87] = 0;
    _$jscoverage["outcomes.coffee"][88] = 0;
    _$jscoverage["outcomes.coffee"][89] = 0;
    _$jscoverage["outcomes.coffee"][90] = 0;
    _$jscoverage["outcomes.coffee"][91] = 0;
    _$jscoverage["outcomes.coffee"][92] = 0;
    _$jscoverage["outcomes.coffee"][93] = 0;
    _$jscoverage["outcomes.coffee"][97] = 0;
    _$jscoverage["outcomes.coffee"][98] = 0;
    _$jscoverage["outcomes.coffee"][102] = 0;
    _$jscoverage["outcomes.coffee"][104] = 0;
    _$jscoverage["outcomes.coffee"][105] = 0;
    _$jscoverage["outcomes.coffee"][106] = 0;
    _$jscoverage["outcomes.coffee"][108] = 0;
    _$jscoverage["outcomes.coffee"][112] = 0;
    _$jscoverage["outcomes.coffee"][114] = 0;
    _$jscoverage["outcomes.coffee"][115] = 0;
    _$jscoverage["outcomes.coffee"][117] = 0;
    _$jscoverage["outcomes.coffee"][119] = 0;
    _$jscoverage["outcomes.coffee"][123] = 0;
    _$jscoverage["outcomes.coffee"][125] = 0;
    _$jscoverage["outcomes.coffee"][126] = 0;
    _$jscoverage["outcomes.coffee"][128] = 0;
    _$jscoverage["outcomes.coffee"][130] = 0;
    _$jscoverage["outcomes.coffee"][134] = 0;
    _$jscoverage["outcomes.coffee"][135] = 0;
    _$jscoverage["outcomes.coffee"][136] = 0;
    _$jscoverage["outcomes.coffee"][138] = 0;
    _$jscoverage["outcomes.coffee"][139] = 0;
    _$jscoverage["outcomes.coffee"][140] = 0;
    _$jscoverage["outcomes.coffee"][142] = 0;
    _$jscoverage["outcomes.coffee"][143] = 0;
    _$jscoverage["outcomes.coffee"][145] = 0;
    _$jscoverage["outcomes.coffee"][149] = 0;
    _$jscoverage["outcomes.coffee"][150] = 0;
    _$jscoverage["outcomes.coffee"][154] = 0;
    _$jscoverage["outcomes.coffee"][158] = 0;
    _$jscoverage["outcomes.coffee"][159] = 0;
    _$jscoverage["outcomes.coffee"][160] = 0;
    _$jscoverage["outcomes.coffee"][162] = 0;
    _$jscoverage["outcomes.coffee"][168] = 0;
    _$jscoverage["outcomes.coffee"][169] = 0;
    _$jscoverage["outcomes.coffee"][171] = 0;
    _$jscoverage["outcomes.coffee"][173] = 0;
    _$jscoverage["outcomes.coffee"][174] = 0;
    _$jscoverage["outcomes.coffee"][177] = 0;
    _$jscoverage["outcomes.coffee"][178] = 0;
    _$jscoverage["outcomes.coffee"][179] = 0;
    _$jscoverage["outcomes.coffee"][180] = 0;
    _$jscoverage["outcomes.coffee"][181] = 0;
    _$jscoverage["outcomes.coffee"][183] = 0;
    _$jscoverage["outcomes.coffee"][184] = 0;
    _$jscoverage["outcomes.coffee"][186] = 0;
    _$jscoverage["outcomes.coffee"][187] = 0;
    _$jscoverage["outcomes.coffee"][191] = 0;
    _$jscoverage["outcomes.coffee"][199] = 0;
    _$jscoverage["outcomes.coffee"][201] = 0;
    _$jscoverage["outcomes.coffee"][207] = 0;
    _$jscoverage["outcomes.coffee"][208] = 0;
    _$jscoverage["outcomes.coffee"][210] = 0;
    _$jscoverage["outcomes.coffee"][211] = 0;
    _$jscoverage["outcomes.coffee"][213] = 0;
    _$jscoverage["outcomes.coffee"][214] = 0;
    _$jscoverage["outcomes.coffee"][215] = 0;
    _$jscoverage["outcomes.coffee"][216] = 0;
    _$jscoverage["outcomes.coffee"][218] = 0;
    _$jscoverage["outcomes.coffee"][222] = 0;
    _$jscoverage["outcomes.coffee"][223] = 0;
    _$jscoverage["outcomes.coffee"][226] = 0;
    _$jscoverage["outcomes.coffee"][227] = 0;
    _$jscoverage["outcomes.coffee"][236] = 0;
    _$jscoverage["outcomes.coffee"][238] = 0;
}

_$jscoverage["outcomes.coffee"].source = ["crypto       = require 'crypto'", "http         = require 'http'", "https        = require 'https'", "url          = require 'url'", "uuid         = require 'node-uuid'", "", "", "xml2js       = require 'xml2js'", "xml_builder  = require 'xmlbuilder'", "", "errors       = require '../errors'", "HMAC_SHA1    = require '../hmac-sha1'", "utils        = require '../utils'", "", "", "navigateXml = (xmlObject, path) ->", "  for part in path.split '.'", "    xmlObject = xmlObject?[part]?[0]", "", "  return xmlObject", "", "", "", "class OutcomeDocument", "", "  constructor: (type, source_did, @outcome_service) ->", "    # Build and configure the document", "    xmldec =", "      version:     '1.0'", "      encoding:    'UTF-8'", "", "    @doc = xml_builder.create 'imsx_POXEnvelopeRequest', xmldec", "    @doc.attribute 'xmlns', 'http://www.imsglobal.org/services/ltiv1p1/xsd/imsoms_v1p0'", "", "    @head = @doc.ele('imsx_POXHeader').ele('imsx_POXRequestHeaderInfo')", "    @body = @doc.ele('imsx_POXBody').ele(type + 'Request').ele('resultRecord')", "", "    # Generate a unique identifier and apply the version to the header information", "    @head.ele 'imsx_version', 'V1.0'", "    @head.ele 'imsx_messageIdentifier', uuid.v1()", "", "    # Apply the source DID to the body", "    @body.ele('sourcedGUID').ele('sourcedId', source_did)", "", "", "  add_score: (score, language) ->", "    if (typeof score != 'number' or score < 0 or score > 1.0)", "      throw new errors.ParameterError 'Score must be a floating point number >= 0 and <= 1'", "", "    eScore = @_result_ele().ele('resultScore')", "    eScore.ele('language', language)", "    eScore.ele('textString', score)", "", "", "  add_text: (text) ->", "    @_add_payload('text', text)", "", "", "  add_url: (url) ->", "    @_add_payload('url', url)", "", "", "  finalize: () ->", "    @doc.end(pretty: true)", "", "", "  _result_ele: () ->", "    @result or (@result = @body.ele('result'))", "", "", "  _add_payload: (type, value) ->", "    throw new errors.ExtensionError('Result data payload has already been set') if @has_payload", "    throw new errors.ExtensionError('Result data type is not supported') if !@outcome_service.supports_result_data(type)", "    @_result_ele().ele('resultData').ele(type, value)", "    @has_payload = true", "", "", "", "class OutcomeService", "", "  REQUEST_REPLACE:  'replaceResult'", "  REQUEST_READ:     'readResult'", "  REQUEST_DELETE:   'deleteResult'", "", "  constructor: (options = {}) ->", "    @consumer_key = options.consumer_key", "    @consumer_secret = options.consumer_secret", "    @service_url = options.service_url", "    @source_did = options.source_did", "    @result_data_types = options.result_data_types or []", "    @signer = options.signer or (new HMAC_SHA1())", "    @cert_authority = options.cert_authority or null", "    @language = options.language or 'en'", "", "    # Break apart the service url into the url fragments for use by OAuth signing, additionally prepare the OAuth", "    # specific url that used exclusively in the signing process.", "    parts = @service_url_parts = url.parse @service_url, true", "    @service_url_oauth = parts.protocol + '//' + parts.host + parts.pathname", "", "", "  send_replace_result: (score, callback) ->", "    doc = new OutcomeDocument @REQUEST_REPLACE, @source_did, @", "", "    try", "      doc.add_score score, @language", "      @_send_request doc, callback", "    catch err", "      callback err, false", "", "", "  send_replace_result_with_text: (score, text, callback) ->", "    doc = new OutcomeDocument @REQUEST_REPLACE, @source_did, @", "", "    try", "      doc.add_score score, @language,", "      doc.add_text text", "      @_send_request doc, callback", "    catch err", "      callback err, false", "", "", "  send_replace_result_with_url: (score, url, callback) ->", "    doc = new OutcomeDocument @REQUEST_REPLACE, @source_did, @", "", "    try", "      doc.add_score score, @language,", "      doc.add_url url", "      @_send_request doc, callback", "    catch err", "      callback err, false", "", "", "  send_read_result: (callback) ->", "    doc = new OutcomeDocument @REQUEST_READ, @source_did, @", "    @_send_request doc, (err, result, xml) =>", "      return callback(err, result) if err", "", "      score = navigateXml(xml, 'imsx_POXBody.readResultResponse.result.resultScore.textString')", "      if (score != '')", "        score = parseFloat score, 10", "", "      if (score != '' && isNaN(score))", "        callback new errors.OutcomeResponseError('Invalid score response', 'invalidlineitemtype'), false", "      else", "        callback null, score", "", "", "  send_delete_result: (callback) ->", "    doc = new OutcomeDocument @REQUEST_DELETE, @source_did, @", "    @_send_request doc, callback", "", "", "  supports_result_data: (type) ->", "    return @result_data_types.length and (!type or @result_data_types.indexOf(type) != -1)", "", "", "  _send_request: (doc, callback) ->", "    xml     = doc.finalize()", "    body    = ''", "    is_ssl  = @service_url_parts.protocol == 'https:'", "", "    options =", "      hostname:  @service_url_parts.hostname", "      path:      @service_url_parts.path", "      method:    'POST'", "      headers:   @_build_headers xml", "", "    if @cert_authority and is_ssl", "      options.ca = @cert_authority", "    else", "      options.agent = if is_ssl then https.globalAgent else http.globalAgent", "", "    if @service_url_parts.port", "      options.port = @service_url_parts.port", "", "    # Make the request to the TC, verifying that the status code is valid and fetching the entire response body.", "    req = (if is_ssl then https else http).request options, (res) =>", "      res.setEncoding 'utf8'", "      res.on 'data', (chunk) => body += chunk", "      res.on 'end', () =>", "        @_process_response body, callback", "", "    req.on 'error', (err) =>", "      callback err, false", "", "    req.write xml", "    req.end()", "", "", "  _build_headers: (body) ->", "    headers =", "      oauth_version:           '1.0'", "      oauth_nonce:             uuid.v4()", "      oauth_timestamp:         Math.round Date.now() / 1000", "      oauth_consumer_key:      @consumer_key", "      oauth_body_hash:         crypto.createHash('sha1').update(body).digest('base64')", "      oauth_signature_method:  'HMAC-SHA1'", "", "    headers.oauth_signature = @signer.build_signature_raw @service_url_oauth, @service_url_parts, 'POST', headers, @consumer_secret", "", "    Authorization:     'OAuth realm=\"\",' + (\"#{key}=\\\"#{utils.special_encode(val)}\\\"\" for key, val of headers).join ','", "    'Content-Type':    'application/xml'", "    'Content-Length':  body.length", "", "", "  _process_response: (body, callback) ->", "    xml2js.parseString body, trim: true, (err, result) =>", "      return callback new errors.OutcomeResponseError('The server responsed with an invalid XML document', 'invaliddata'), false if err", "", "      response  = result?.imsx_POXEnvelopeResponse", "      code      = navigateXml response, 'imsx_POXHeader.imsx_POXResponseHeaderInfo.imsx_statusInfo.imsx_codeMajor'", "", "      if code != 'success'", "        msg = navigateXml response, 'imsx_POXHeader.imsx_POXResponseHeaderInfo.imsx_statusInfo.imsx_description'", "        codeMinor = navigateXml response, 'imsx_POXHeader.imsx_POXResponseHeaderInfo.imsx_statusInfo.imsx_codeMinor'", "        callback new errors.OutcomeResponseError(msg, codeMinor), false", "      else", "        callback null, true, response", "", "", "", "exports.init = (provider) ->", "  if (provider.body.lis_outcome_service_url and provider.body.lis_result_sourcedid)", "    # The LTI 1.1 spec says that the language parameter is usually implied to be en, so the OutcomeService object", "    # defaults to en until the spec updates and says there's other possible format options.", "    accepted_vals = provider.body.ext_outcome_data_values_accepted", "    provider.outcome_service = new OutcomeService(", "      consumer_key: provider.consumer_key", "      consumer_secret: provider.consumer_secret", "      service_url: provider.body.lis_outcome_service_url,", "      source_did: provider.body.lis_result_sourcedid,", "      result_data_types: accepted_vals and accepted_vals.split(',') or []", "      signer: provider.signer", "    )", "  else", "    provider.outcome_service = false", "", "exports.OutcomeService = OutcomeService", ""];

(function() {
  var HMAC_SHA1, OutcomeDocument, OutcomeService, crypto, errors, http, https, navigateXml, url, utils, uuid, xml2js, xml_builder;

  _$jscoverage["outcomes.coffee"][1]++;

  crypto = require('crypto');

  _$jscoverage["outcomes.coffee"][2]++;

  http = require('http');

  _$jscoverage["outcomes.coffee"][3]++;

  https = require('https');

  _$jscoverage["outcomes.coffee"][4]++;

  url = require('url');

  _$jscoverage["outcomes.coffee"][5]++;

  uuid = require('node-uuid');

  _$jscoverage["outcomes.coffee"][8]++;

  xml2js = require('xml2js');

  _$jscoverage["outcomes.coffee"][9]++;

  xml_builder = require('xmlbuilder');

  _$jscoverage["outcomes.coffee"][11]++;

  errors = require('../errors');

  _$jscoverage["outcomes.coffee"][12]++;

  HMAC_SHA1 = require('../hmac-sha1');

  _$jscoverage["outcomes.coffee"][13]++;

  utils = require('../utils');

  _$jscoverage["outcomes.coffee"][16]++;

  navigateXml = function(xmlObject, path) {
    var i, len, part, ref, ref1;
    _$jscoverage["outcomes.coffee"][17]++;
    ref = path.split('.');
    for (i = 0, len = ref.length; i < len; i++) {
      part = ref[i];
      _$jscoverage["outcomes.coffee"][18]++;
      xmlObject = xmlObject != null ? (ref1 = xmlObject[part]) != null ? ref1[0] : void 0 : void 0;
    }
    _$jscoverage["outcomes.coffee"][20]++;
    return xmlObject;
  };

  _$jscoverage["outcomes.coffee"][24]++;

  OutcomeDocument = (function() {
    _$jscoverage["outcomes.coffee"][26]++;

    function OutcomeDocument(type, source_did, outcome_service) {
      var xmldec;
      this.outcome_service = outcome_service;
      _$jscoverage["outcomes.coffee"][28]++;
      xmldec = {
        version: '1.0',
        encoding: 'UTF-8'
      };
      _$jscoverage["outcomes.coffee"][32]++;
      this.doc = xml_builder.create('imsx_POXEnvelopeRequest', xmldec);
      _$jscoverage["outcomes.coffee"][33]++;
      this.doc.attribute('xmlns', 'http://www.imsglobal.org/services/ltiv1p1/xsd/imsoms_v1p0');
      _$jscoverage["outcomes.coffee"][35]++;
      this.head = this.doc.ele('imsx_POXHeader').ele('imsx_POXRequestHeaderInfo');
      _$jscoverage["outcomes.coffee"][36]++;
      this.body = this.doc.ele('imsx_POXBody').ele(type + 'Request').ele('resultRecord');
      _$jscoverage["outcomes.coffee"][39]++;
      this.head.ele('imsx_version', 'V1.0');
      _$jscoverage["outcomes.coffee"][40]++;
      this.head.ele('imsx_messageIdentifier', uuid.v1());
      _$jscoverage["outcomes.coffee"][43]++;
      this.body.ele('sourcedGUID').ele('sourcedId', source_did);
    }

    OutcomeDocument.prototype.add_score = function(score, language) {
      var eScore;
      _$jscoverage["outcomes.coffee"][47]++;
      if (typeof score !== 'number' || score < 0 || score > 1.0) {
        _$jscoverage["outcomes.coffee"][48]++;
        throw new errors.ParameterError('Score must be a floating point number >= 0 and <= 1');
      }
      _$jscoverage["outcomes.coffee"][50]++;
      eScore = this._result_ele().ele('resultScore');
      _$jscoverage["outcomes.coffee"][51]++;
      eScore.ele('language', language);
      _$jscoverage["outcomes.coffee"][52]++;
      return eScore.ele('textString', score);
    };

    OutcomeDocument.prototype.add_text = function(text) {
      _$jscoverage["outcomes.coffee"][56]++;
      return this._add_payload('text', text);
    };

    OutcomeDocument.prototype.add_url = function(url) {
      _$jscoverage["outcomes.coffee"][60]++;
      return this._add_payload('url', url);
    };

    OutcomeDocument.prototype.finalize = function() {
      _$jscoverage["outcomes.coffee"][64]++;
      return this.doc.end({
        pretty: true
      });
    };

    OutcomeDocument.prototype._result_ele = function() {
      _$jscoverage["outcomes.coffee"][68]++;
      return this.result || (this.result = this.body.ele('result'));
    };

    OutcomeDocument.prototype._add_payload = function(type, value) {
      _$jscoverage["outcomes.coffee"][72]++;
      if (this.has_payload) {
        throw new errors.ExtensionError('Result data payload has already been set');
      }
      _$jscoverage["outcomes.coffee"][73]++;
      if (!this.outcome_service.supports_result_data(type)) {
        throw new errors.ExtensionError('Result data type is not supported');
      }
      _$jscoverage["outcomes.coffee"][74]++;
      this._result_ele().ele('resultData').ele(type, value);
      _$jscoverage["outcomes.coffee"][75]++;
      return this.has_payload = true;
    };

    return OutcomeDocument;

  })();

  _$jscoverage["outcomes.coffee"][79]++;

  OutcomeService = (function() {
    _$jscoverage["outcomes.coffee"][81]++;

    OutcomeService.prototype.REQUEST_REPLACE = 'replaceResult';

    OutcomeService.prototype.REQUEST_READ = 'readResult';

    OutcomeService.prototype.REQUEST_DELETE = 'deleteResult';

    function OutcomeService(options) {
      var parts;
      if (options == null) {
        options = {};
      }
      _$jscoverage["outcomes.coffee"][86]++;
      this.consumer_key = options.consumer_key;
      _$jscoverage["outcomes.coffee"][87]++;
      this.consumer_secret = options.consumer_secret;
      _$jscoverage["outcomes.coffee"][88]++;
      this.service_url = options.service_url;
      _$jscoverage["outcomes.coffee"][89]++;
      this.source_did = options.source_did;
      _$jscoverage["outcomes.coffee"][90]++;
      this.result_data_types = options.result_data_types || [];
      _$jscoverage["outcomes.coffee"][91]++;
      this.signer = options.signer || (new HMAC_SHA1());
      _$jscoverage["outcomes.coffee"][92]++;
      this.cert_authority = options.cert_authority || null;
      _$jscoverage["outcomes.coffee"][93]++;
      this.language = options.language || 'en';
      _$jscoverage["outcomes.coffee"][97]++;
      parts = this.service_url_parts = url.parse(this.service_url, true);
      _$jscoverage["outcomes.coffee"][98]++;
      this.service_url_oauth = parts.protocol + '//' + parts.host + parts.pathname;
    }

    OutcomeService.prototype.send_replace_result = function(score, callback) {
      var doc, err;
      _$jscoverage["outcomes.coffee"][102]++;
      doc = new OutcomeDocument(this.REQUEST_REPLACE, this.source_did, this);
      _$jscoverage["outcomes.coffee"][104]++;
      try {
        _$jscoverage["outcomes.coffee"][105]++;
        doc.add_score(score, this.language);
        _$jscoverage["outcomes.coffee"][106]++;
        return this._send_request(doc, callback);
      } catch (error) {
        err = error;
        _$jscoverage["outcomes.coffee"][108]++;
        return callback(err, false);
      }
    };

    OutcomeService.prototype.send_replace_result_with_text = function(score, text, callback) {
      var doc, err;
      _$jscoverage["outcomes.coffee"][112]++;
      doc = new OutcomeDocument(this.REQUEST_REPLACE, this.source_did, this);
      _$jscoverage["outcomes.coffee"][114]++;
      try {
        _$jscoverage["outcomes.coffee"][115]++;
        doc.add_score(score, this.language, doc.add_text(text));
        _$jscoverage["outcomes.coffee"][117]++;
        return this._send_request(doc, callback);
      } catch (error) {
        err = error;
        _$jscoverage["outcomes.coffee"][119]++;
        return callback(err, false);
      }
    };

    OutcomeService.prototype.send_replace_result_with_url = function(score, url, callback) {
      var doc, err;
      _$jscoverage["outcomes.coffee"][123]++;
      doc = new OutcomeDocument(this.REQUEST_REPLACE, this.source_did, this);
      _$jscoverage["outcomes.coffee"][125]++;
      try {
        _$jscoverage["outcomes.coffee"][126]++;
        doc.add_score(score, this.language, doc.add_url(url));
        _$jscoverage["outcomes.coffee"][128]++;
        return this._send_request(doc, callback);
      } catch (error) {
        err = error;
        _$jscoverage["outcomes.coffee"][130]++;
        return callback(err, false);
      }
    };

    OutcomeService.prototype.send_read_result = function(callback) {
      var doc;
      _$jscoverage["outcomes.coffee"][134]++;
      doc = new OutcomeDocument(this.REQUEST_READ, this.source_did, this);
      _$jscoverage["outcomes.coffee"][135]++;
      return this._send_request(doc, (function(_this) {
        return function(err, result, xml) {
          var score;
          _$jscoverage["outcomes.coffee"][136]++;
          if (err) {
            return callback(err, result);
          }
          _$jscoverage["outcomes.coffee"][138]++;
          score = navigateXml(xml, 'imsx_POXBody.readResultResponse.result.resultScore.textString');
          _$jscoverage["outcomes.coffee"][139]++;
          if (score !== '') {
            _$jscoverage["outcomes.coffee"][140]++;
            score = parseFloat(score, 10);
          }
          _$jscoverage["outcomes.coffee"][142]++;
          if (score !== '' && isNaN(score)) {
            _$jscoverage["outcomes.coffee"][143]++;
            return callback(new errors.OutcomeResponseError('Invalid score response', 'invalidlineitemtype'), false);
          } else {
            _$jscoverage["outcomes.coffee"][145]++;
            return callback(null, score);
          }
        };
      })(this));
    };

    OutcomeService.prototype.send_delete_result = function(callback) {
      var doc;
      _$jscoverage["outcomes.coffee"][149]++;
      doc = new OutcomeDocument(this.REQUEST_DELETE, this.source_did, this);
      _$jscoverage["outcomes.coffee"][150]++;
      return this._send_request(doc, callback);
    };

    OutcomeService.prototype.supports_result_data = function(type) {
      _$jscoverage["outcomes.coffee"][154]++;
      return this.result_data_types.length && (!type || this.result_data_types.indexOf(type) !== -1);
    };

    OutcomeService.prototype._send_request = function(doc, callback) {
      var body, is_ssl, options, req, xml;
      _$jscoverage["outcomes.coffee"][158]++;
      xml = doc.finalize();
      _$jscoverage["outcomes.coffee"][159]++;
      body = '';
      _$jscoverage["outcomes.coffee"][160]++;
      is_ssl = this.service_url_parts.protocol === 'https:';
      _$jscoverage["outcomes.coffee"][162]++;
      options = {
        hostname: this.service_url_parts.hostname,
        path: this.service_url_parts.path,
        method: 'POST',
        headers: this._build_headers(xml)
      };
      _$jscoverage["outcomes.coffee"][168]++;
      if (this.cert_authority && is_ssl) {
        _$jscoverage["outcomes.coffee"][169]++;
        options.ca = this.cert_authority;
      } else {
        _$jscoverage["outcomes.coffee"][171]++;
        options.agent = is_ssl ? https.globalAgent : http.globalAgent;
      }
      _$jscoverage["outcomes.coffee"][173]++;
      if (this.service_url_parts.port) {
        _$jscoverage["outcomes.coffee"][174]++;
        options.port = this.service_url_parts.port;
      }
      _$jscoverage["outcomes.coffee"][177]++;
      req = (is_ssl ? https : http).request(options, (function(_this) {
        return function(res) {
          _$jscoverage["outcomes.coffee"][178]++;
          res.setEncoding('utf8');
          _$jscoverage["outcomes.coffee"][179]++;
          res.on('data', function(chunk) {
            return body += chunk;
          });
          _$jscoverage["outcomes.coffee"][180]++;
          return res.on('end', function() {
            _$jscoverage["outcomes.coffee"][181]++;
            return _this._process_response(body, callback);
          });
        };
      })(this));
      _$jscoverage["outcomes.coffee"][183]++;
      req.on('error', (function(_this) {
        return function(err) {
          _$jscoverage["outcomes.coffee"][184]++;
          return callback(err, false);
        };
      })(this));
      _$jscoverage["outcomes.coffee"][186]++;
      req.write(xml);
      _$jscoverage["outcomes.coffee"][187]++;
      return req.end();
    };

    OutcomeService.prototype._build_headers = function(body) {
      var headers, key, val;
      _$jscoverage["outcomes.coffee"][191]++;
      headers = {
        oauth_version: '1.0',
        oauth_nonce: uuid.v4(),
        oauth_timestamp: Math.round(Date.now() / 1000),
        oauth_consumer_key: this.consumer_key,
        oauth_body_hash: crypto.createHash('sha1').update(body).digest('base64'),
        oauth_signature_method: 'HMAC-SHA1'
      };
      _$jscoverage["outcomes.coffee"][199]++;
      headers.oauth_signature = this.signer.build_signature_raw(this.service_url_oauth, this.service_url_parts, 'POST', headers, this.consumer_secret);
      _$jscoverage["outcomes.coffee"][201]++;
      return {
        Authorization: 'OAuth realm="",' + ((function() {
          var results;
          results = [];
          for (key in headers) {
            val = headers[key];
            results.push(key + "=\"" + (utils.special_encode(val)) + "\"");
          }
          return results;
        })()).join(','),
        'Content-Type': 'application/xml',
        'Content-Length': body.length
      };
    };

    OutcomeService.prototype._process_response = function(body, callback) {
      _$jscoverage["outcomes.coffee"][207]++;
      return xml2js.parseString(body, {
        trim: true
      }, (function(_this) {
        return function(err, result) {
          var code, codeMinor, msg, response;
          _$jscoverage["outcomes.coffee"][208]++;
          if (err) {
            return callback(new errors.OutcomeResponseError('The server responsed with an invalid XML document', 'invaliddata'), false);
          }
          _$jscoverage["outcomes.coffee"][210]++;
          response = result != null ? result.imsx_POXEnvelopeResponse : void 0;
          _$jscoverage["outcomes.coffee"][211]++;
          code = navigateXml(response, 'imsx_POXHeader.imsx_POXResponseHeaderInfo.imsx_statusInfo.imsx_codeMajor');
          _$jscoverage["outcomes.coffee"][213]++;
          if (code !== 'success') {
            _$jscoverage["outcomes.coffee"][214]++;
            msg = navigateXml(response, 'imsx_POXHeader.imsx_POXResponseHeaderInfo.imsx_statusInfo.imsx_description');
            _$jscoverage["outcomes.coffee"][215]++;
            codeMinor = navigateXml(response, 'imsx_POXHeader.imsx_POXResponseHeaderInfo.imsx_statusInfo.imsx_codeMinor');
            _$jscoverage["outcomes.coffee"][216]++;
            return callback(new errors.OutcomeResponseError(msg, codeMinor), false);
          } else {
            _$jscoverage["outcomes.coffee"][218]++;
            return callback(null, true, response);
          }
        };
      })(this));
    };

    return OutcomeService;

  })();

  _$jscoverage["outcomes.coffee"][222]++;

  exports.init = function(provider) {
    var accepted_vals;
    _$jscoverage["outcomes.coffee"][223]++;
    if (provider.body.lis_outcome_service_url && provider.body.lis_result_sourcedid) {
      _$jscoverage["outcomes.coffee"][226]++;
      accepted_vals = provider.body.ext_outcome_data_values_accepted;
      _$jscoverage["outcomes.coffee"][227]++;
      return provider.outcome_service = new OutcomeService({
        consumer_key: provider.consumer_key,
        consumer_secret: provider.consumer_secret,
        service_url: provider.body.lis_outcome_service_url,
        source_did: provider.body.lis_result_sourcedid,
        result_data_types: accepted_vals && accepted_vals.split(',') || [],
        signer: provider.signer
      });
    } else {
      _$jscoverage["outcomes.coffee"][236]++;
      return provider.outcome_service = false;
    }
  };

  _$jscoverage["outcomes.coffee"][238]++;

  exports.OutcomeService = OutcomeService;

}).call(this);
